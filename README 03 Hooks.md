# 1. Hooks
## 1. Hooks란
### 1. 기존 리엑트에서는 클래스형 컴포넌트로 개발이 주로 이뤄졌다. 함수형 컴포넌트에는 state, props 또는 ref등의 생명주기를 관리할 수 있는 기능이 없었다.


### 2. Hooks라는 기능이 등장하면서 함수형 컴포넌트에서도 state, props, ref 등의 생명주기를 관리할 수 있는 기능이 추가되면서 형재는 대부분 함수형 컴포넌트를 사용하고 있다.

### 3. Hooks는 컴포넌트의 상태관리 변수를 생성하는 useState, 렌더링 직후의 동작을 지정할 수 있는 useEffect등과 같은 기능을 제공해주는 라이브러리



## 2. useEffect

### 1. 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 할 수 있는 Hook
### 2. 처음 렌더링될 때와 리렌더링될 때 지정한 작업을 수행

```

useEffect( ()=>{
  
  //렌더링시  실행될 작업
  
  },[] // 어떤 상태값의 변화에 따라 작업을 실행할 것인지. 빈칸이면 초기 렌더링시에 작업 실행
  
  );

```

리액트는 전부 비동기라서 순서를 잘 만들어야됨. 어떤게 먼저 실행될지 모름.

num1이 바뀐 다음에 num2로 바뀌어라 이렇게 설정을 해줘야됨.

### 3. react는 거의 대부분 비동기로 동작하는 데 동작하는 시점을 동기화하여 맞춰줄 때 주로 사용한다.

### 4. useEffect에서 cleanup 메소드를 리턴하면 state값이 변경되기 직전에 실행될 내용을 작성할 수 있다.

```

useEffect(  ()=>{
   
   
   return ()=>{
   
   //cleanup 메소드
   //state 값이 변경되기 전에 실행될 내용 작성
   
   
   
   }
   }, [state]);
```

## 3. useReducer
### 1. 컴포넌의 상황에 따라 state값을 다른 값으로 업데이트 하고 싶을 때 사용하는 hook
### 2. useReducer는 현재 state값과 업데이트를 위해 필요한 정보를 담고 있는 액션을 매개변수로 받아서 사용한다.
```

function reducer(state, action){

//action의 타입에 따라서 실행될 내용 작성
}
const [state, dispatch] = useReducer(reducer, { state의 초기값 });
```


### 3. dispatch는 action을 실행시키는 메소드, dispatch(action) => action을 발생시킨다. 발생시키면서 reducer로 지정된 메소드를 호출한다.

### 4. reducer로 지정될 메소드는 컴포넌트밖에 선언한다.


## 4. usecallback

### 1. usecallback은 렌더링 성능을 최적화할 때 사용하는 hook

### 2. 컴포넌트에 정의해놓은 메소드들은 렌더링될 때마다 재생성되는데 usecallback을 이용하면 메소들이 재생성되는것을 방지할 수 있다.

### 3. usecallback 정의해놓은 메소드의 재사용성을 높일 수 있고 메소드가 생성되는 시점을 지정할 수 있다.

```
const 메소드명 = usecallback(  ()=>{

//메소드의 동작 구현

},[]//최초 렌더링 시에만 메소드 생성, 상태변수 값을 줘서 상태변수가 변할 때마다 메소드를 재생성. )

```

## 5. useMemo
### 1. useMemo는 연산을 최적화해주는 hook
### 2. 상태값이 변할때만 연산이 이루어지도록 지정할 수 있어서 불필요한 연산이 일어나는 것을 방지할 수 있다.


````
useMEmo(  ()=>{
//상태변수의 값이 변했을 때 일어날 연산

},[상태변수] )

useMEmo(  ()=>미리 지정해놓은 연산메소드(),[상태변수] )
이렇게해도 된다.
````

## 6. useRef
### 1. Html에서는 DOM 태그의 식별자로 id를 주로 사용했는데 react에서는 id 대신에 ref를 사용한다.

### 2. react에서 동일한 컴포넌트를 여러번 사용했을 때 id의 유일성이 파괴되기 때문에 id를 식별자로 사용할 수 없다.

### 3. jsx는 ref를 이용해서 같은 컴포넌트가 여러번 사용되어도 유일한 ref값을 지정할 수 있다.

### 4. 유일한 ref값을 만들어주는 Hook이 useRef


````
const 변수명 = useRef();

//유일한 ref값을 갖는 dom태그
<input ref = {변수명}>

````

### 5. useRef 이용 시 선택자 없이도 해당 DOM에 접근할 수 있다.



